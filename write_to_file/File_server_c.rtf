{\rtf1\ansi\ansicpg949\cocoartf2576
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
\
------------------------------------------\
|                                        |\
|     This code was written using C      |\
|                                        |\
|       Compile on Unix or Linux         |\
|                                        |\
|              2018.9.30                 |\
------------------------------------------\
\
\
\
This code creates a new file called test.txt, \
\
waits for a request from the client, \
\
and sends a connection message when it is connected to the client.\
\
*/\
\
#include <stdio.h>\
#include <stdlib.h>\
#include <string.h>\
#include <fcntl.h>\
#include <unistd.h>\
#include <arpa/inet.h>\
#include <sys/socket.h>\
#define BUF_SIZE 100\
\
void error_handling(char *message);\
\
int main(int argc, char *argv[])\
\{\
	int sock, str_len, f;\
	char message[BUF_SIZE];\
	char buf[BUF_SIZE];\
	struct sockaddr_in serv_addr;\
	\
	if(argc != 3)\
	\{\
		printf("Usage : %s <IP> <Port>\\n", argv[0]);\
		exit(1);\
	\}\
	\
	//socket 
\f1 \'bb\'fd\'bc\'ba
\f0  | Create socket\
	sock = socket(PF_INET, SOCK_STREAM, 0);\
\
	//socket 
\f1 \'bb\'fd\'bc\'ba\'bf\'a1
\f0  
\f1 \'b4\'eb\'c7\'d1
\f0  
\f1 \'bf\'a1\'b7\'af
\f0  
\f1 \'b8\'de\'bc\'bc\'c1\'f6
\f0  
\f1 \'c3\'e2\'b7\'c2
\f0  | If can't create a socket, print error message\
	if(sock == -1)\
		error_handling("Not created socket....");\
\
	//
\f1 \'c1\'d6\'bc\'d2
\f0  
\f1 \'c1\'a4\'ba\'b8\'b8\'a6
\f0  
\f1 \'b4\'e3\'c0\'bb
\f0  
\f1 \'b1\'b8\'c1\'b6\'c3\'bc
\f0  
\f1 \'c3\'ca\'b1\'e2\'c8\'ad
\f0  | Initialize the structure of the address information\
	memset(&serv_addr, 0, sizeof(serv_addr));\
	serv_addr.sin_family = AF_INET;\
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);\
	serv_addr.sin_port = htons(atoi(argv[2]));\
	\
	//
\f1 \'bf\'ac\'b0\'e1
\f0  
\f1 \'bd\'c3\'b5\'b5
\f0  | Connection attempt\
	if(connect(sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)\
		error_handling("couldn't send request!");\
\
	//
\f1 \'bc\'ad\'b9\'f6\'b7\'ce\'ba\'ce\'c5\'cd
\f0  
\f1 \'c1\'a2\'bc\'d3
\f0  
\f1 \'bc\'ba\'b0\'f8
\f0  
\f1 \'b8\'de\'bc\'bc\'c1\'f6
\f0  
\f1 \'b9\'de\'b1\'e2
\f0  | Receive a connection success message from the server\
	str_len = read(sock, message, sizeof(message)-1);\
	if(str_len == -1)\
		error_handling("Can't read server's message");\
	\
	//
\f1 \'bc\'ad\'b9\'f6\'b7\'ce\'ba\'ce\'c5\'cd
\f0  
\f1 \'b9\'de\'c0\'ba
\f0  
\f1 \'c1\'a2\'bc\'d3
\f0  
\f1 \'bc\'ba\'b0\'f8
\f0  
\f1 \'b8\'de\'bc\'bc\'c1\'f6
\f0  
\f1 \'c3\'e2\'b7\'c2
\f0  | Print connection success message from server\
	printf("\\nMessage from server : %s \\n", message);\
\
\
	//test.txt
\f1 \'c6\'c4\'c0\'cf\'c0\'bb
\f0  
\f1 \'c0\'d0\'b1\'e2
\f0  
\f1 \'b8\'f0\'b5\'e5\'b7\'ce
\f0  
\f1 \'bf\'ad\'b1\'e2
\f0  | Open the test.txt in Read mode\
    	f = open("test.txt", O_RDONLY);\
	\
	//
\f1 \'c6\'c4\'c0\'cf
\f0  
\f1 \'bf\'ad\'b1\'e2
\f0  
\f1 \'bf\'c0\'b7\'f9
\f0  
\f1 \'bd\'c3
\f0  
\f1 \'bf\'a1\'b7\'af
\f0  
\f1 \'b8\'de\'bc\'bc\'c1\'f6
\f0  
\f1 \'c3\'e2\'b7\'c2
\f0  | 	If can't open the file, print error message\
    	if(f == -1)\
        	error_handling("Couldn't created file");\
\
	//
\f1 \'c6\'c4\'c0\'cf\'c0\'c7
\f0  
\f1 \'b3\'bb\'bf\'eb
\f0  
\f1 \'c0\'d0\'b1\'e2
\f0  | Read the file's data\
	if(read(f, buf, sizeof(buf)) == -1)\
        	error_handling("Can't read from the server's file");\
\
	printf("File data : %s", buf);\
	\
	//
\f1 \'bc\'d2\'c4\'cf
\f0  
\f1 \'b4\'dd\'b1\'e2
\f0  | Close sockets\
	close(sock);\
	close(f);\
\
	return 0;\
\}\
\
void error_handling(char *message)\
\{\
	fputs(message, stderr);\
	fputc('\\n', stderr);\
	exit(1);\
\}}